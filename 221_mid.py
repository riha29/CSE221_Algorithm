# -*- coding: utf-8 -*-
"""221_mid.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1H9W4V5VDTLnWoeZU7SsK-212TmKsjFyO
"""

# max sum subarray --------------- TC O(n)

def maxSubArray(nums):
    max_current = max_global = nums[0]
    for i in range(1, len(nums)):
        max_current = max(nums[i], max_current + nums[i])
        if max_current > max_global:
            max_global = max_current
    return max_global


# max sum subarray --------------- TC O(n^2)

def maxSubArray(nums):
    max_sum = float('-inf')  # initialize max_sum with negative infinity
    for i in range(len(nums)):
        current_sum = 0
        for j in range(i, len(nums)):
            current_sum += nums[j]
            if current_sum > max_sum:
                max_sum = current_sum
    return max_sum


# max sum subarray --------------- TC O(n^3)

def maxSubArray(nums):
    max_sum = float('-inf')  # initialize max_sum with negative infinity
    for i in range(len(nums)):
        for j in range(i, len(nums)):
            current_sum = 0
            for k in range(i, j + 1):
                current_sum += nums[k]
            max_sum = max(max_sum, current_sum)
    return max_sum

# count inversion------------------- TC O(n^2)

def count_inversions_naive(arr):
    count = 0
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if arr[i] > arr[j]:
                count += 1
    return count


# count inversion------------------- TC O(nlogn)

def merge_and_count(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m
    # Create temp arrays
    left = arr[l:l+n1]
    right = arr[m+1:m+1+n2]
    # Merge the temp arrays back into arr[l..r]
    i = j = 0     # Initial indexes of first and second subarrays
    k = l     # Initial index of merged subarray
    inversions = 0
    while i < n1 and j < n2:
        if left[i] <= right[j]:
            arr[k] = left[i]
            i += 1
        else:
            arr[k] = right[j]
            inversions += (n1 - i)
            j += 1
        k += 1
    # Copy the remaining elements of left[], if there are any
    while i < n1:
        arr[k] = left[i]
        i += 1
        k += 1
    # Copy the remaining elements of right[], if there are any
    while j < n2:
        arr[k] = right[j]
        j += 1
        k += 1
    return inversions
def count_inversions(arr, l, r):
    inversions = 0
    if l < r:
        m = (l + r) // 2
        # Count inversions in first half, second half and inversions during merge
        inversions += count_inversions(arr, l, m)
        inversions += count_inversions(arr, m + 1, r)
        inversions += merge_and_count(arr, l, m, r)
    return inversions